#!/usr/bin/perl
# Pipestat, A nice tool to get statistics from any text in a pipe
# Copyright Audun Ytterdal <audun@ytterdal.net>
# Licenced under GPL Version 2.

# TODO: field 4-5 4,6 etc
# TODO: Merge ($1) ($2) etc.
# TODO: Remove hits/s when cat'ing files
# TODO: Removing stuff like where field='S' etc

use Getopt::Long;
#use Data::Dumper;
use Time::HiRes qw( time );

# Unbuffered output
$| = 1;

# Catch Ctrl-C and friends
$SIG{INT} = \&end_pipe;

my $opt_linefreq; # Default none
my $opt_timefreq=5; # Default every 5 second
my $opt_maxtime=60; # Default 60 seconds
my $opt_maxlines=5000000; # Stop at five million lines 
my $opt_regex = 0;
my $opt_case  = 0;
my $opt_limit = 0;
my $opt_field;
my $opt_delimiter = '\s+'; #Default delimiter is one or more spaces
my $opt_help = 0;
my $opt_clear=0; #Don't clean screen
my $opt_hits=1; # show hits per second

my $result = GetOptions(
"t|timefreq=i"  => \$opt_timefreq,   # how often do we update in time
"m|maxtime=i"   => \$opt_maxtime,    # when to stop
"maxlines=i"    => \$opt_maxlines,   # when to stop
"linefreq=i"    => \$opt_linefreq,   # how often do we update in lines
"r|regex"       => \$opt_regex,      # regexp or match as key
"s|case"        => \$opt_case,       # key sensetive?
"c|clear"       => \$opt_clear,      # clear and updatescreen?
"f|field=s"     => \$opt_field,      # what field to use?
"d|delimiter=s" => \$opt_delimiter,  # What delimiter to use
"h|hits"        => \$opt_hits,       # show hits/s
"l|limit=i"     => \$opt_limit,      # how many do we print
"h|help"        => \$opt_help        # Print help 
);                                      

if ($opt_help) {
    &help;
}

# The hash where we store objects
my $objects;

# counters
my $freqcount = 0;
my $starttime = time();
my $freqtime  = $starttime;
my $lines     = 0;
my $now = time();

while (<STDIN>) {
    $now = time();
    if ($opt_maxtime) {
        if ($now - $starttime >= $opt_maxtime) {
            print "Maxtime of $opt_maxtime seconds reached.\n\n";
            &end_pipe;
        }
    }
    if ($opt_maxlines) {
        if ($lines >= $opt_maxlines) {
            print "Maxlines of $opt_maxlines reached.\n\n";
            &end_pipe;
        }
    }
    my $line = $_;
    chomp $line;            # remove trailing newlines
    for my $reg (@ARGV) {
        if ($opt_case) {
            if ( $line =~ m/$reg/ ) {
                if ($opt_regex) {

                    $objects->{$1}++;    # add match as key
                }
                else {
                    $objects->{$reg}++;    # add regexp as key
                }
            }
        }
        else {
            if ( $line =~ m/$reg/i ) {     # caseinsensetive is default
                if ($opt_regex) {
                    $objects->{$1}++;      # add match as key
                }
                else {
                    $objects->{$reg}++;    # add regexps as key
                }
            }
        }
    }
    if ( !@ARGV ) {    # we didn't send regexp, count every line
        if ($opt_field) {    # which field to use
            my @fields    = split(",",$opt_field);
            my @fieldlist = split(/$opt_delimiter/,$line);
            my $object;
            for my $field (@fields) {
                $object .= "$fieldlist[($field-1)] ";
            }
            chop($object);
            $objects->{$object}++;
        }
        else {
            $objects->{$line}++;
        }
    }
    $freqcount++;
    if ($opt_linefreq) {    # print out every <n> lines
        printout( $objects, $lines, $starttime ) if ( $freqcount >= $opt_linefreq );
        $freqcount = 0;
    }
    if ($opt_timefreq) {    # print out every <n> seconds
        if ( time() - $freqtime >= $opt_timefreq ) {
            printout( $objects, $lines, $starttime );
            $freqtime = time();
        }

    }
    $lines++;

}
&end_pipe;                  # we only get here if the pipe is closed.

sub printout {
    my ( $objects, $lines, $starttime ) = @_;
    my $diff   = time() - $starttime;
    my $hitsum = 0;
    my $limit  = 0;
    my $hitlimit;
    my $limitedhits = 0;
    if ($opt_clear) {       # if set, clear screen between prints
        my $clear = `tput clear`;
        print $clear;
    }

    # sort the hash values and print descending
    for my $reg ( sort { $objects->{$b} <=> $objects->{$a} } keys %$objects ) {
        $hitsum += $objects->{$reg};
        if ( !$hitlimit ) {    # only print untill we hit the limit
            if ($opt_hits) {
                printf(
                    "%-25s : (%.1f%%) (%.1f hits/s) (%d hits / %d)\n",
                    $reg,
                    ( $objects->{$reg} / $lines ) * 100,
                    $objects->{$reg} / $diff,
                    $objects->{$reg}, $lines
                );
            }
            else {
                printf(
                    "%-25s : (%.1f%%) (%d hits / %d)\n",
                    $reg, ( $objects->{$reg} / $lines ) * 100,
                    $objects->{$reg}, $lines
                );
            }
        }
        else {
            $limitedhits += $objects->{$reg};
        }
        $limit++;
        if ( $opt_limit && $limit >= $opt_limit ) {
            $hitlimit++;
        }
    }
    if ($hitlimit) {
        if ($opt_hits) {
            printf(
                "%-25s : (%.1f%%) (%.1f hits/s) (%d(%d) hits(uniq) / %d)\n",
                "<limited>",
                ( $limitedhits / $lines ) * 100,
                $limitedhits / $diff,
                $limitedhits, $hitlimit, $lines
            );
        }
        else {
            printf(
                "%-25s : (%.1f%%) (%d(%d) hits(uniq) / %d)\n",
                "<limited>", ( $limitedhits / $lines ) * 100,
                $limitedhits, $hitlimit, $lines
            );
        }
    }
    my $rest = $lines - $hitsum;
    if ($rest) {
        if ($opt_hits) {
            printf(
                "%-25s : (%.1f%%) (%.1f hits/s) (%d hits / %d)\n",
                "<rest>",
                ( $rest / $lines ) * 100,
                $rest / $diff,
                $rest, $lines
            );
        }
        else {
            printf(
                "%-25s : (%.1f%%) (%d hits / %d)\n",
                "<rest>", ( $rest / $lines ) * 100,
                $rest, $lines
            );
        }
    }
    print "\n";
}

sub end_pipe {
    printout( $objects, $lines, $starttime );
    my $diff = time() - $starttime;
    printf( "Parsed %d lines in %.2f secs (%.1f lines/s)\n",
        $lines, $diff, $lines / $diff );
    exit;
}

sub help {
    print "pipestat usage\n";
    print "someprogram | pipestat [options] [regexps]\n";
    print "options:\n";
    print " -r|--regex     # Create key from match\n";
    print " -t|--timefreq  # How often do we update in time (default: 5 seconds)\n";
    print " -m|--maxtime   # Stop after this number of seconds (default: 60 seconds)\n";
    print " --linefreq    # How often do we update in lines (default: never\n";
    print " --maxlines    # Max number of lines do we read (default 5 million)\n";
    print " -s|--case      # Be case sensetive (default: caseinsensetive)\n";
    print " -c|--clear     # Clear screen between updates (default: no)\n";
    print " -f|--field     # what field to use?\n";
    print " -d|--delimiter # What regex delimiter to use (default: space)\n";
    print " -h|--hits      # Show hits/s (default: on\n";
    print " -l|--limit     # Limit how many to print (default: all)\n";
    print " -h|--help      # Show this help\n";
    print "\n";
    print "Examples\n";
    print "tail -f /var/log/httpd/access.log | pipestat -r 'GET ([^\s]+)'\n";
    print "tail -f /var/log/httpd/access.log | pipestat --field 6";
    exit;
}
